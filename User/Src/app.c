/**
 * @file    app.c
 * @brief   Main application logic.
 *
 * @details
 * This module implements the basic logic of the device.
 *
 * Functionality:
 * - initialization of all application modules
 * - periodic polling of the LM35 and BME280 sensors
 * - button event processing
 * - LCD value updates
 * - data accumulation in ring buffers
 * - graph display
 * - centralized error handling
 *
 * Architecture:
 * - the module belongs to the Application layer
 * - does not contain direct work with peripherals (GPIO, ADC, I2C)
 * - uses the API of the underlying modules
 *
 * System configuration:
 * - the project does NOT use auto-generation of the STM32CubeMX code
 * - clock and peripheral initialization is performed manually
 * - only HAL and BSP are used as library dependencies
 *
 * Reasons:
 * - full control over initialization and configuration
 * - visual demonstration of understanding the STM32 peripherals
 * - lack of hidden logic generated by tools
 *
 * Timings:
 * - the main loop is updated with the APP_TICK_MS period
 *
 * Limitations:
 * - the module is not thread-safe
 * - single-threaded execution is assumed (bare-metal)
 */

#include "app.h"
#include "lm35.h"
#include "bme280.h"
#include "display.h"
#include "graph.h"
#include "buttons.h"
#include "ring_buffer.h"
#include "system_init.h"
#include "error.h"

// Main loop period (ms)
#define APP_TICK_MS 500

// The time of the last app update
static uint32_t last_tick = 0;

// Sensor data structures
static BME280_Data_t bme;
static LM35_Data_t lm35;

// Ring buffer structures to save the history of values
static RingBuffer bme280_ring_buffer_temp;
static RingBuffer bme280_ring_buffer_press;
static RingBuffer bme280_ring_buffer_hum;
static RingBuffer lm35_ring_buffer_temp;

// Arrays for ring buffers
static float bme280_buffer_temp[GRAPH_POINTS];
static float bme280_buffer_press[GRAPH_POINTS];
static float bme280_buffer_hum[GRAPH_POINTS];
static float lm35_buffer_temp[GRAPH_POINTS];

// Initialization of ring buffers with arrays
static void RB_Sensors_Init(void)
{
    RB_Init(&bme280_ring_buffer_temp, bme280_buffer_temp, sizeof(bme280_buffer_temp) / sizeof(float));
    RB_Init(&bme280_ring_buffer_press, bme280_buffer_press, sizeof(bme280_buffer_press) / sizeof(float));
	RB_Init(&bme280_ring_buffer_hum, bme280_buffer_hum, sizeof(bme280_buffer_hum) / sizeof(float));
	RB_Init(&lm35_ring_buffer_temp, lm35_buffer_temp, sizeof(lm35_buffer_temp) / sizeof(float));
}


/**
 * @brief Initializing the application.
 *
 * Sequence:
 * - initialization of the system and clocking
 * - initialization of error indication
 * - initialization of the display and UI
 * - initialization of buttons
 * - initialization of sensors
 * - initialization of buffers and graphics
 *
 * In case of a critical error:
 * - execution stops
 * - error is displayed on the LCD
 */
void App_Init(void)
{
	if (!System_Init())
		Error_Trigger(SYSTEM_INIT_ERROR);

	ErrorLED_Init();

	if (!Display_Init())
		Error_Trigger(LCD_INIT_ERROR);

    Buttons_Init();

    if (!LM35_Init())
    	Error_Trigger(LM35_INIT_ERROR);
    if (!BME280_Init())
    	Error_Trigger(BME280_INIT_ERROR);

    RB_Sensors_Init();

    if (!Graph_Init(&lm35_ring_buffer_temp, &bme280_ring_buffer_temp,
   		&bme280_ring_buffer_press, &bme280_ring_buffer_hum))
    {
    	Error_Trigger(GRAPH_INIT_ERROR);
    }

    // Drawing of non updatable titles of sensors
    Display_DrawStatic();
}


/**
 * @brief Main application cycle.
 *
 * Is called from the infinite main() loop.
 *
 * Logic:
 * - handling active errors
 * - check the refresh timer
 * - button event processing
 * - sensor reading
 * - display and graph updates
 *
 * @note
 * The function does not block execution and
 * should be called as often as possible.
 */
void App_Loop(void)
{
	// Handling of active errors
    Error_Handle();

    uint32_t now = HAL_GetTick();

    // Limiting the frequency of application updates
    if (now - last_tick < APP_TICK_MS)
        return;

    last_tick = now;

    // Switching the graph display mode
    if (Buttons_GetEvent(BUTTON_GRAPH_MODE))
    {
    	if (Is_Graph_Initialised())
    	{
    		GraphMode m = Graph_GetMode();
    		if (m == GRAPH_MODE_HUMIDITY)
    			m = GRAPH_MODE_TEMPERATURE;
    		else
    			++m;
    		Graph_SetMode(m);
    	}
    }

    // Setting the relative height reference point
    if (Buttons_GetEvent(BUTTON_SET_BASE_PRESSURE))
    {
    	BME280_SetBasePressure(bme.pressure);
    }

    // Reading LM35
    if (LM35_Read(&lm35))
    {
    	Error_Clear(LM35_READ_VALUE_ERROR);
    	Display_UpdateSensors(NULL, &lm35);
    	RB_Push(&lm35_ring_buffer_temp, lm35.temperature_c);
    }
    else
    {
    	// In case of an error, we write down a marker and signal
    	RB_Push(&lm35_ring_buffer_temp, SENSOR_ERROR_VALUE);
    	Error_Trigger(LM35_READ_VALUE_ERROR);
    }

    // Reading BME280
    if (BME280_Read(&bme))
    {
    	Error_Clear(BME280_READ_VALUE_ERROR);
    	Display_UpdateSensors(&bme, NULL);
    	RB_Push(&bme280_ring_buffer_temp, bme.temperature);
    	RB_Push(&bme280_ring_buffer_press, bme.pressure / PA_TO_MMHG);
    	RB_Push(&bme280_ring_buffer_hum, bme.humidity);
    }
    else
    {
    	// In case of an error, we write down are markers and signal
    	RB_Push(&bme280_ring_buffer_temp, SENSOR_ERROR_VALUE);
    	RB_Push(&bme280_ring_buffer_press, SENSOR_ERROR_VALUE);
    	RB_Push(&bme280_ring_buffer_hum, SENSOR_ERROR_VALUE);
    	Error_Trigger(BME280_READ_VALUE_ERROR);
    }

    // Redrawing the graph
    Graph_Draw();
}
